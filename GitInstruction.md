![Logo](Git-Logo-2Color.png)
# Работа с GIT

## 1. Проверка наличия установленного Git
В терминале выполнить команду git version
Если Git установлен появится сообщение о версии программы, иначе будет сообщение об ошибке.
## 2. Установка Git
Загружаем последнюю версию Git с сайта:
[Загрузка Git](https://git-scm.com/downloads).
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовании Git необходимо предствиться. Для этого нужно ввести в терминале две команды:
```
git config --global user.name «Ваше имя
английскими буквами»
git config --global user.email ваша почта
```

## 4. Инициализация репозитория
В терминале переходим к папке, в которой хотим создать репозиторий. Выполняем команду:
```
git init
```

## 5. Запись изменений в репозиторий
### Определение состояния файлов
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда ```git status```.
Пример использования команды и результат ее вывода:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Это означает, что в каталоге нет отслеживаемых изменённых файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. В данном случае это ветка master, ветка по умолчанию.

### Отслеживание новых файлов
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда ```git add```.
Пример использования команды:
```
$ git add README
```
При выполнении команды ```git status``` видно, что файл README теперь отслеживаемый и добавлен в индекс:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```
Видно, что файл проиндексирован, так как он находится в секции «Changes to be committed».

### Просмотр индексированных и неиндексированных изменений
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:
```
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
 ```
 Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.

Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить ```git diff --staged``` или ```git diff --cached``` -  синонимы. Эта команда сравнивает ваши проиндексированные изменения с последним коммитом:
```
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
```

### Коммит изменений
Простейший способ зафиксировать изменения — это команда ```git commit```. Эта команда откроет выбранный вами текстовый редактор.

В редакторе будет отображён следующий текст (это пример окна Vim):
```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
```

Вы можете видеть, что комментарий по умолчанию для коммита содержит закомментированный результат работы команды ```git status``` и ещё одну пустую строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же оставить их для напоминания о том, что вы фиксируете.

Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением, удаляя комментарии и вывод команды ```diff```.

Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра ```-m```:
```
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
```

## 6. Просмотр истории коммитов
Одним из основных и наиболее мощных инструментов для просмотра истории коммитов является команда ```git log```:
```
% git log
commit e69ba0eb415edf66eef64dec06f7cbd4c80cb29b (HEAD -> main)
Author: Evgeny <eusmirnov51@gmail.com>
Date:   Mon Jul 17 12:22:12 2023 +0300

    Добавлена информация в раздел 5

commit 43f9b1c9657b325687908c9c398d55711fb59f3e
Author: Evgeny <eusmirnov51@gmail.com>
Date:   Sun Jul 9 12:05:56 2023 +0300

    Добавлена информация в раздел 4

commit 1610c555ebfe8c3de55d37ffa6ae772fb3421ad2
Author: Evgeny <eusmirnov51@gmail.com>
Date:   Sun Jul 9 11:54:00 2023 +0300

    Добавлен раздел 2

commit 6aac0491823268a5a822cd74d1672931b9edd9c1
Author: Evgeny <eusmirnov51@gmail.com>
Date:   Sun Jul 9 11:47:58 2023 +0300

    1 раздел

commit 80e28548e343a041cf0b94fed6b76deb4273a349
Author: Evgeny <eusmirnov51@gmail.com>
Date:   Sun Jul 9 11:45:34 2023 +0300
```
Наиболее распространённые опции для команды ```git log```:

| Опция | Описание |
| ------ | ------ |
| ```-p``` | Показывает патч для каждого коммита. |
| ```--stat``` | Показывает статистику изменённых файлов для каждого коммита. |
| ```--shortstat``` | Отображает только строку с количеством изменений/вставок/удалений для команды ```--stat```. |
| ```--name-only``` | Показывает список изменённых файлов после информации о коммите. |
| ```--name-status``` | Показывает список файлов, которые добавлены/изменены/удалены. |
| ```--abbrev-commit``` | Показывает только несколько символов SHA-1 чек-суммы вместо всех 40. |
| ```--relative-date``` | Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты. |
| ```--graph``` | Отображает ASCII граф с ветвлениями и историей слияний. |
| ```--pretty``` | Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней можно указать  свой формат). |
| ```--oneline``` | Сокращение для одновременного использования опций ```--pretty=oneline --abbrev-commit```. |

## 7. Перемещение между сохранениями
Команда ```git checkout``` используется для переключения веток и выгрузки их содержимого в рабочий каталог.

При выполнении следующей команды указатель HEAD будет перенесен на последний коммит ветки <название-ветки>.
```
git checkout ＜branchname＞
```

Чтобы вернуться в основную ветку, необходимо выполнить команду:

```
git checkout master
```

## 8. Игнорирование файлов
Для того, чтобы исключить из отслеживания в репозитории определённые файлы или папки необходимо создать там файл ***.gitignore*** и записать в него названия файлов или папок, либо использовать шаблоны.

## 9. Создание веток в GIT
По умолчанию имя оснвной ветки в Git -
*master*.
Создать ветку можно командой:
```
git branch <ветка>
```
Список веток в репозитории можно посмотреть с помощью команды:
```
git branch
```
Текущая ветка будет отмечена звёздочкой: **\* master**

## 10. Слияние веток и разрешение конфликтов
Для слияния выбранной ветки с текущей нужно выполнить команду:
```
git merge <название выбранной ветки>
```
Если была изменена одна и та же часть файла в обеих ветках, то может возникнуть конфликт, который потребует участия пользователя.
VSCode предлагает варианты разрешения.
Чтобы разрешить конфликт нужно выбрать один из вариантов, либо объединить содержимое по-своему.
После разрешения конфликта нужно выполнить коммит слияния.

## 11. Удаление веток
Команда для удаления локальной ветки в Git:
```
git branch -d  branch_name
```
- ```git branch``` – команда для удаления локальной ветки.
- ```-d``` – флаг, опция команды git branch, сокращенный вариант записи --delete. Как и следует из названия, предназначен для удаления ветки.
- ```branch_name``` – имя удаляемой ветки.

Если в ветке присутствуют несмерженные изменения или незапушенные коммиты, флаг -d не позволит удалить такую локальную ветку.

Это связано с тем, что эти коммиты нигде более не отслеживаются, и Git защищает вас от случайной потери этих данных.

Если все же попытаться удалить такую ветку, Git выдаст ошибку:
```
git branch -d test 2
error: The branch 'test 2' is not fully merged.
If you are sure you want to delete it, run git branch -D test 2'
```

Для принудительного удаления неслитой ветки необходимо использовать команду:
```
git branch -D branch_name
```
Флаг **-D** с большой D (сокращенная запись опции --delete --force), принудительно удаляет локальную ветку, вне зависимости от ее статуса мержа.
## Работа с удаленными репозиториями
### Просмотр удаленных репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:
```
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
```
Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:
```
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
```

### Получение изменений из удалённого репозитория — Fetch и Pull
Для получения данных из удалённых проектов, следует выполнить:
```
$ git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, ```git fetch origin``` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду `git pull` чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда `git clone` автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение `git pull`, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

### Отправка изменений в удалённый репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: git push <remote-name> <branch-name>. Чтобы отправить вашу ветку master на сервер origin , вы можете выполнить следующую команду для отправки ваших коммитов:
```
$ git push origin master
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду `push`. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду `push`, а после него выполнить команду push попытаетесь вы, то ваш `push` точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push.